<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Backend Connection Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
    }
    .test-section {
      background: #2a2a2a;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      border-left: 4px solid #666;
    }
    .test-section.success {
      border-left-color: #22c55e;
    }
    .test-section.error {
      border-left-color: #ef4444;
    }
    .test-section.warning {
      border-left-color: #f59e0b;
    }
    button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #2563eb;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    .status {
      padding: 10px;
      margin: 10px 0;
      background: #1a1a1a;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    .log {
      max-height: 300px;
      overflow-y: auto;
      background: #0a0a0a;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
    }
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-left: 3px solid #666;
      padding-left: 10px;
    }
    .log-entry.info { border-left-color: #3b82f6; }
    .log-entry.success { border-left-color: #22c55e; }
    .log-entry.error { border-left-color: #ef4444; }
    .log-entry.warning { border-left-color: #f59e0b; }
  </style>
</head>
<body>
  <h1>üß™ Backend Connection Error Flow Testing</h1>
  <p>Test suite for Video Orchestrator backend connection error handling</p>

  <div class="test-section" id="healthCheck">
    <h2>1. Health Check</h2>
    <button onclick="testHealthCheck()">Test Health Check</button>
    <button onclick="testHealthCheckTimeout()">Test with Timeout</button>
    <div id="healthStatus" class="status"></div>
  </div>

  <div class="test-section" id="retryLogic">
    <h2>2. Retry Logic</h2>
    <button onclick="testRetryLogic()">Test Retry with Exponential Backoff</button>
    <button onclick="clearRetryTest()">Clear</button>
    <div id="retryStatus" class="status"></div>
  </div>

  <div class="test-section" id="connectionLoss">
    <h2>3. Connection Loss Simulation</h2>
    <button onclick="testConnectionLoss()">Simulate Connection Loss</button>
    <button onclick="testConnectionRecover()">Simulate Recovery</button>
    <div id="connectionStatus" class="status"></div>
  </div>

  <div class="test-section" id="apiErrors">
    <h2>4. API Error Scenarios</h2>
    <button onclick="testScriptGeneration()">Test Script Generation</button>
    <button onclick="testBackgroundImport()">Test Background Import</button>
    <button onclick="testTTSGeneration()">Test TTS Generation</button>
    <div id="apiStatus" class="status"></div>
  </div>

  <div class="test-section">
    <h2>üìã Test Log</h2>
    <button onclick="clearLog()">Clear Log</button>
    <div id="testLog" class="log"></div>
  </div>

  <script>
    const API_BASE = 'http://127.0.0.1:4545';
    let retryCount = 0;

    function log(message, type = 'info') {
      const logDiv = document.getElementById('testLog');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      const timestamp = new Date().toLocaleTimeString();
      entry.textContent = `[${timestamp}] ${message}`;
      logDiv.insertBefore(entry, logDiv.firstChild);
    }

    function clearLog() {
      document.getElementById('testLog').innerHTML = '';
    }

    // Test 1: Basic Health Check
    async function testHealthCheck() {
      const statusDiv = document.getElementById('healthStatus');
      statusDiv.textContent = 'Testing health check...';
      log('Starting health check test', 'info');

      try {
        const response = await fetch(`${API_BASE}/health`, { timeout: 5000 });
        const data = await response.json();
        
        if (response.ok) {
          statusDiv.textContent = `‚úÖ Success: ${JSON.stringify(data, null, 2)}`;
          document.getElementById('healthCheck').classList.add('success');
          log(`Health check successful: ${data.data.status}`, 'success');
        } else {
          statusDiv.textContent = `‚ùå Failed with status ${response.status}`;
          document.getElementById('healthCheck').classList.add('error');
          log(`Health check failed: ${response.status}`, 'error');
        }
      } catch (error) {
        statusDiv.textContent = `‚ùå Error: ${error.message}`;
        document.getElementById('healthCheck').classList.add('error');
        log(`Health check error: ${error.message}`, 'error');
      }
    }

    async function testHealthCheckTimeout() {
      const statusDiv = document.getElementById('healthStatus');
      statusDiv.textContent = 'Testing health check with timeout...';
      log('Testing health check with 100ms timeout', 'info');

      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 100);
        
        const response = await fetch(`${API_BASE}/health`, { 
          signal: controller.signal 
        });
        clearTimeout(timeout);
        
        const data = await response.json();
        statusDiv.textContent = `‚úÖ Response: ${JSON.stringify(data, null, 2)}`;
      } catch (error) {
        if (error.name === 'AbortError') {
          statusDiv.textContent = `‚è±Ô∏è Timeout after 100ms (expected behavior)`;
          log('Timeout test successful - request aborted as expected', 'warning');
        } else {
          statusDiv.textContent = `‚ùå Error: ${error.message}`;
          log(`Unexpected error: ${error.message}`, 'error');
        }
      }
    }

    // Test 2: Retry Logic
    async function testRetryLogic() {
      const statusDiv = document.getElementById('retryStatus');
      const maxRetries = 3;
      retryCount = 0;
      
      statusDiv.textContent = 'Starting retry test...\n';
      log('Testing retry logic with exponential backoff', 'info');

      for (let i = 0; i < maxRetries; i++) {
        const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s
        statusDiv.textContent += `\nAttempt ${i + 1}/${maxRetries} - waiting ${delay}ms...`;
        log(`Retry attempt ${i + 1}/${maxRetries} (delay: ${delay}ms)`, 'warning');
        
        await new Promise(resolve => setTimeout(resolve, delay));
        
        try {
          const response = await fetch(`${API_BASE}/health`);
          if (response.ok) {
            statusDiv.textContent += `\n‚úÖ Connected on attempt ${i + 1}`;
            document.getElementById('retryLogic').classList.add('success');
            log(`Connection successful on attempt ${i + 1}`, 'success');
            return;
          }
        } catch (error) {
          statusDiv.textContent += `\n‚ùå Attempt ${i + 1} failed: ${error.message}`;
          log(`Attempt ${i + 1} failed: ${error.message}`, 'error');
        }
      }

      statusDiv.textContent += `\n\n‚ùå All ${maxRetries} attempts failed`;
      document.getElementById('retryLogic').classList.add('error');
      log('All retry attempts exhausted', 'error');
    }

    function clearRetryTest() {
      document.getElementById('retryStatus').textContent = '';
      document.getElementById('retryLogic').classList.remove('success', 'error');
    }

    // Test 3: Connection Loss
    async function testConnectionLoss() {
      const statusDiv = document.getElementById('connectionStatus');
      statusDiv.textContent = 'Simulating connection loss...\n';
      log('Simulating connection loss scenario', 'warning');

      const pollInterval = setInterval(async () => {
        try {
          const response = await fetch(`${API_BASE}/health`, { timeout: 2000 });
          if (response.ok) {
            statusDiv.textContent += `\n[${new Date().toLocaleTimeString()}] ‚úÖ Connected`;
            log('Polling: Backend connected', 'success');
          } else {
            statusDiv.textContent += `\n[${new Date().toLocaleTimeString()}] ‚ö†Ô∏è Unhealthy (${response.status})`;
            log(`Polling: Backend unhealthy (${response.status})`, 'warning');
          }
        } catch (error) {
          statusDiv.textContent += `\n[${new Date().toLocaleTimeString()}] ‚ùå Connection lost`;
          document.getElementById('connectionLoss').classList.add('error');
          log('Polling: Connection lost', 'error');
        }
      }, 5000);

      // Store interval ID for cleanup
      window.currentPollInterval = pollInterval;
      
      statusDiv.textContent += '\n\nüì° Polling every 5 seconds...\nStop the backend to test connection loss.\n';
      log('Started health check polling (5s interval)', 'info');
    }

    async function testConnectionRecover() {
      if (window.currentPollInterval) {
        clearInterval(window.currentPollInterval);
        window.currentPollInterval = null;
        log('Stopped health check polling', 'info');
      }

      const statusDiv = document.getElementById('connectionStatus');
      statusDiv.textContent = 'Testing connection recovery...';
      log('Testing connection recovery', 'info');

      try {
        const response = await fetch(`${API_BASE}/health`);
        if (response.ok) {
          statusDiv.textContent = '‚úÖ Connection recovered successfully!';
          document.getElementById('connectionLoss').classList.remove('error');
          document.getElementById('connectionLoss').classList.add('success');
          log('Connection recovered successfully', 'success');
        } else {
          statusDiv.textContent = `‚ö†Ô∏è Backend responding but unhealthy (${response.status})`;
          log(`Backend unhealthy: ${response.status}`, 'warning');
        }
      } catch (error) {
        statusDiv.textContent = `‚ùå Still disconnected: ${error.message}`;
        log(`Recovery failed: ${error.message}`, 'error');
      }
    }

    // Test 4: API Error Scenarios
    async function testScriptGeneration() {
      const statusDiv = document.getElementById('apiStatus');
      statusDiv.textContent = 'Testing script generation API...';
      log('Testing /ai/script endpoint', 'info');

      try {
        const response = await fetch(`${API_BASE}/ai/script`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            topic: 'Test story about error handling',
            genre: 'horror'
          })
        });

        const data = await response.json();
        
        if (response.ok) {
          statusDiv.textContent = `‚úÖ Script generated (${data.data.script.length} chars)`;
          document.getElementById('apiErrors').classList.add('success');
          log('Script generation successful', 'success');
        } else {
          statusDiv.textContent = `‚ùå Error: ${data.error?.message || JSON.stringify(data)}`;
          document.getElementById('apiErrors').classList.add('error');
          log(`Script generation failed: ${data.error?.message}`, 'error');
        }
      } catch (error) {
        statusDiv.textContent = `‚ùå Network error: ${error.message}`;
        document.getElementById('apiErrors').classList.add('error');
        log(`Network error in script generation: ${error.message}`, 'error');
      }
    }

    async function testBackgroundImport() {
      const statusDiv = document.getElementById('apiStatus');
      statusDiv.textContent = 'Testing background import API...';
      log('Testing /assets/backgrounds/import endpoint', 'info');

      // Create a tiny test file
      const blob = new Blob(['test video content'], { type: 'video/mp4' });
      const formData = new FormData();
      formData.append('video', blob, 'test-video.mp4');

      try {
        const response = await fetch(`${API_BASE}/assets/backgrounds/import`, {
          method: 'POST',
          body: formData
        });

        const data = await response.json();
        
        if (response.ok) {
          statusDiv.textContent = `‚úÖ Background imported: ${data.data.id}`;
          log('Background import successful', 'success');
        } else {
          statusDiv.textContent = `‚ùå Error: ${data.error?.message || JSON.stringify(data)}`;
          log(`Background import failed: ${data.error?.message}`, 'error');
        }
      } catch (error) {
        statusDiv.textContent = `‚ùå Network error: ${error.message}`;
        log(`Network error in background import: ${error.message}`, 'error');
      }
    }

    async function testTTSGeneration() {
      const statusDiv = document.getElementById('apiStatus');
      statusDiv.textContent = 'Testing TTS generation API...';
      log('Testing /tts/generate endpoint', 'info');

      try {
        const response = await fetch(`${API_BASE}/tts/generate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: 'This is a test of the text to speech system.',
            voice: 'en_US-lessac-medium',
            speed: 1.0
          })
        });

        const data = await response.json();
        
        if (response.ok) {
          statusDiv.textContent = `‚úÖ TTS generated: ${data.data.audioId}`;
          log('TTS generation successful', 'success');
        } else {
          statusDiv.textContent = `‚ùå Error: ${data.error?.message || JSON.stringify(data)}`;
          log(`TTS generation failed: ${data.error?.message}`, 'error');
        }
      } catch (error) {
        statusDiv.textContent = `‚ùå Network error: ${error.message}`;
        log(`Network error in TTS generation: ${error.message}`, 'error');
      }
    }

    // Initialize
    log('Backend connection test suite loaded', 'info');
    log(`Target: ${API_BASE}`, 'info');
  </script>
</body>
</html>
